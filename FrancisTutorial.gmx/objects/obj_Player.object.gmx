<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Facing = 0
WeaponCount = 0
SelectedWeaponIndex = 0

Power = 5
PowerMax = 10 //75

ResetShunts()

//Weapons are now invisible and will be immediately picked up when player spawns
//Could remove the "pickup" code and just attach weapons to player, but why bother
instance_create(x,y,obj_RapidFireGun)
instance_create(x,y,obj_BaitGun)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* Movement */
MySpeed = 300 / room_speed
//This resets the player's speed to 0 every frame, so that key has to be pressed to move
//and ensures addons to speed are not cumulative from frame to frame (see collision code below)
speed = 0
if keyboard_check(ord('W'))
{
    vspeed = -MySpeed
}
if keyboard_check(ord('S'))
{
    vspeed = MySpeed

}
if keyboard_check(ord('A'))
{
    hspeed = -MySpeed
}
if keyboard_check(ord('D'))
{
    hspeed = MySpeed
}

/* Collision Code*/
//Ensure player cannot be shunted through the wall during kick of weapon for example)
//then reset shunt to 0 to make sure player is shunted only once per call
//xShunt and yShunt are altered in the obj_BaitGun and obj_RapidFireGun Step events
hspeed = hspeed + xShunt
vspeed = vspeed + yShunt
ResetShunts()

//This code stops us the frame before we hit a solid object.
//Adding hspeed/vspeed (and xShunt/yShunt if it's been altered) to the current x/y
//coord permits us to test the location of the next frame and stop us when we're
//about to hit a solid object
//This code also permits us to move when we hit a solid object, but only in direction not blocked
if place_meeting(x + hspeed, y + vspeed, obj_Solid)
{
    //Keep as much of our horizontal speed as possible
    OldHspeed = hspeed
    hspeed = 0
    while
        place_meeting(x + hspeed + sign(OldHspeed), y, obj_Solid) = false //Check there's still room if we crept a bit closer to our old hspeed
        and
        abs(hspeed) &lt; abs(OldHspeed) //Check we haven't restored all of our old hspeed - use abs() to make sure not checking a positive against a negative
    {
        //Add 1 to hspeed is positive, subtract 1 if hspeed is negative
        //and creep towards old hpseed
        hspeed = hspeed + sign(OldHspeed)
    }
    
    //We have now figured out how much of our speed we can keep without hitting anything
    
    //Keep as much of our vertical speed as possible
    OldVspeed = vspeed
    vspeed = 0
    while
        //Note that below we've added hspeed to x because we calculated above the hspeed we can keep without hitting anything
        place_meeting(x + hspeed, y + vspeed + sign(OldVspeed), obj_Solid) = false //Check there's still room if we crept a bit closer to our old vspeed
        and
        abs(vspeed) &lt; abs(OldVspeed) //Check we haven't restored all of our old vspeed - use abs() to make sure not checking a positive against a negative
    {
        //Add 1 to vspeed is positive, subtract 1 if vspeed is negative
        //and creep towards old vpseed
        vspeed = vspeed + sign(OldVspeed)
    }
}

/* Weapon Switching */
if mouse_check_button_pressed(mb_right)
{
    //Switch to the next weapon up
    SelectedWeaponIndex = SelectedWeaponIndex + 1
    //Loop to zero when exceed number of weapons
    if SelectedWeaponIndex &gt;= WeaponCount
    {
        SelectedWeaponIndex = 0
    }
}

/* Facing */
//See Draw Event for code. Rotation of draw event is now set to 'Facing'
Facing = point_direction(x,y,mouse_x,mouse_y)

/* Power Up */
if Power &gt;= PowerMax
{
    //go to next level
    SaveInventory() //Save file before going to next room - when new room is entered the InitializeRoom script is called when has LoadInventory()
    if room_exists(room_next(room)) room_goto_next() //Checks to make sure there is a next room
} else
{
    PowerUpCollected = instance_place(x,y,obj_PowerUp)
    if instance_exists(PowerUpCollected)
    {
        with PowerUpCollected { instance_destroy() }
        Power = Power + 1
    }
}
/* Player to stay in room */
if x &lt; 0 {x = 0}
if y &lt; 0 {y = 0}
if x &gt; room_width {x = room_width}
if y &gt; room_height {y = room_height}

/* Death */
//Look for enemy touching us
EnemyTouchingMe = instance_place(x,y,obj_Enemy)

//If there is one...
if instance_exists(EnemyTouchingMe)
{
    ScreenShake(80)
    //Kill all Swarmers on screen so that Player can respawn without being surrounded
    //Could just have Player's chunks kill Swarmers in a bubble around player - maybe later
    with obj_Swarmer
    {
        ExplodeIntoANumberOfChunks(5,obj_SwarmerChunk)
        instance_destroy()
    }
    ExplodeIntoANumberOfChunks(obj_Game.NumberOfBitsPlayerIsMadeOf,obj_PlayerChunk)
    //Player death sound
    audio_play_sound(snd_PlayerExplode,1,false)
    //Destroy player
    instance_destroy()
    //Below is necessary to prevent multiple weapon respawning when player respawns
    with obj_BaitGun { instance_destroy() }
    with obj_RapidFireGun { instance_destroy() }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Draw our sprite normally but facing our 'Facing' direction without changing image_angle
//so as to not affect collision

//Only variable changed from default is the 'rotation' variable
draw_sprite_ext(sprite_index,image_index,x,y,image_xscale,image_yscale,Facing,image_blend,image_alpha)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
